#!/usr/bin/env python

import argparse
import json
import os
import logging
import re
import itertools
import datetime
import signal

import requests
import slimit
import slimit.visitors.nodevisitor
import slimit.ast
import dateutil.parser
import pytz
import aniso8601


parser = argparse.ArgumentParser()
parser.add_argument('race', help='Race url fragment.')

args = parser.parse_args()
logging.basicConfig(level=logging.INFO)
logging.getLogger("requests.packages.urllib3").setLevel(logging.WARN)

race_path = os.path.join('races', args.race)

with open(os.path.join(race_path, 'riders.json')) as f:
    riders = json.load(f)

session = requests.Session()
session.headers['User-Agent'] = 'Mozilla/5.0 (X11; Linux x86_64; rv:39.0) Gecko/20100101 Firefox/39.0'

recived_at_re = re.compile('received at: (.*?) <br />')


def datetime_parse_localized_to_utc(localalize_str):
    dt_parse_tzinfos = {
        "BST": 3600
    }
    brackets_removed = localalize_str.replace('(', '').replace(')', '')
    try:
        localized = dateutil.parser.parse(brackets_removed, tzinfos=dt_parse_tzinfos)
    except ValueError as e:
        raise ValueError('{}: {}'.format(str(e), brackets_removed))
    return localized.astimezone(pytz.utc)


def get_points_from_spot_js(js_text):
    spot_js = slimit.parser.Parser().parse(js_text)
    location = None
    for node in slimit.visitors.nodevisitor.visit(spot_js):
        if isinstance(node, slimit.ast.Assign):
            children = node.children()
            idnt = children[0].to_ecma()
            if idnt == 'point':
                for subnode in slimit.visitors.nodevisitor.visit(node):
                    if isinstance(subnode, list):
                        location = tuple((float(item.to_ecma()) for item in subnode))
        if isinstance(node, slimit.ast.FunctionCall):
            children = node.children()
            idnt = children[0].to_ecma()
            if idnt == 'infowindow.setContent':
                recived_at_m = recived_at_re.search(children[1].to_ecma())
                recived_at_utc = datetime_parse_localized_to_utc(recived_at_m.group(1))
                yield (recived_at_utc, location[0], location[1])


def json_datetime_encoder(obj):
    if isinstance(obj, (datetime.datetime, datetime.date)):
        return obj.isoformat()
    raise TypeError


def json_datetime_decoder(dict_):
    for key, value in dict_.iteritems():
        # The built-in `json` library will `unicode` strings, except for empty
        # strings which are of type `str`. `jsondate` patches this for
        # consistency so that `unicode` is always returned.
        if value == b'':
            dict_[key] = u''
        try:
            dict_[key] = aniso8601.parse_datetime(value)
        except (ValueError, TypeError):
            pass

    return dict_


class DelayedKeyboardInterrupt(object):
    def __enter__(self):
        self.signal_received = False
        self.old_handler = signal.getsignal(signal.SIGINT)
        signal.signal(signal.SIGINT, self.handler)

    def handler(self, signal, frame):
        self.signal_received = (signal, frame)
        logging.debug('SIGINT received. Delaying KeyboardInterrupt.')

    def __exit__(self, type, value, traceback):
        signal.signal(signal.SIGINT, self.old_handler)
        if self.signal_received:
            self.old_handler(*self.signal_received)

for rider in riders:
    try:
        logging.info('Getting data for {name}'.format(**rider))
        rider_path = os.path.join(race_path, rider['url_fragment'])

        rider_points_path = os.path.join(rider_path, 'points.json')
        if os.path.exists(rider_points_path):
            with open(rider_points_path) as f:
                oldpoints = json.load(f, object_hook=json_datetime_decoder)
        else:
            oldpoints = []
        oldpoints = [tuple(point) for point in oldpoints]

        spot_js_response = session.get('http://trackleaders.com/spot/{}/{}.js'.format(args.race, rider['url_fragment']))
        spot_js_response.raise_for_status()
        newpoints = get_points_from_spot_js(spot_js_response.text)

        points_set = set(itertools.chain(oldpoints, newpoints))
        points_sorted = list(sorted(points_set))
        with DelayedKeyboardInterrupt():
            if not os.path.exists(rider_path):
                os.mkdir(rider_path)
            with open(rider_points_path, 'w') as f:
                json.dump(points_sorted, f, indent=2, default=json_datetime_encoder)

    except Exception:
        logging.exception('Error for {name}'.format(**rider))

